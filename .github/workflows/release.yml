name: Release

on:
  workflow_dispatch:
    inputs:
      dry_run:
        description: 'Dry run (preview changes without committing)'
        required: false
        type: boolean
        default: false
      build_android:
        description: 'Build Android app (requires EAS to be configured)'
        required: false
        type: boolean
        default: false
      build_ios:
        description: 'Build iOS app (requires EAS and Apple credentials to be configured)'
        required: false
        type: boolean
        default: false

permissions:
  contents: write

# Prevent concurrent releases
concurrency:
  group: release
  cancel-in-progress: false

jobs:
  # Validate before release
  validate:
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: web-app
    steps:
      - name: Checkout
        uses: actions/checkout@v6

      - name: Setup Node.js with dependencies
        uses: ./.github/actions/setup-node-deps
        with:
          working-directory: web-app

      - name: Generate API types
        run: npm run generate:api

      - name: Lint
        run: npm run lint

      - name: Knip (dead code detection)
        run: npm run knip

      - name: Test
        run: npm test

      - name: Build
        run: npm run build

  release:
    needs: validate
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.get_version.outputs.version }}
      released: ${{ steps.get_version.outputs.released }}
    steps:
      - name: Verify RELEASE_TOKEN is configured
        env:
          RELEASE_TOKEN: ${{ secrets.RELEASE_TOKEN }}
        run: |
          if [ -z "$RELEASE_TOKEN" ]; then
            echo "::error::RELEASE_TOKEN secret is not configured."
            echo "::error::This token is required to bypass branch protection rules."
            echo "::error::See: https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/managing-your-personal-access-tokens"
            exit 1
          fi
          echo "RELEASE_TOKEN is configured"

      - name: Checkout
        uses: actions/checkout@v6
        with:
          fetch-depth: 0
          token: ${{ secrets.RELEASE_TOKEN }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '22'

      - name: Install root dependencies (changesets)
        run: npm install

      - name: Configure Git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"

      - name: Check for changesets
        id: check_changesets
        run: |
          # Count changeset files (excluding config.json and README.md)
          CHANGESET_COUNT=$(find .changeset -name "*.md" ! -name "README.md" | wc -l)
          echo "changeset_count=$CHANGESET_COUNT" >> "$GITHUB_OUTPUT"

          if [ "$CHANGESET_COUNT" -eq 0 ]; then
            echo "::warning::No changesets found. Nothing to release."
          else
            echo "Found $CHANGESET_COUNT changeset(s)"
          fi

      - name: Version packages (Changesets)
        if: steps.check_changesets.outputs.changeset_count != '0'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Run changeset version (monorepo workspaces are configured in root package.json)
          # web-app/CHANGELOG.md is a symlink to ../CHANGELOG.md
          npx changeset version

          # Sync package-lock.json with the new version in package.json
          npm install --package-lock-only

      - name: Sync mobile app.json version
        if: steps.check_changesets.outputs.changeset_count != '0'
        run: |
          # Get the new version from mobile package.json
          MOBILE_VERSION=$(node -p "require('./packages/mobile/package.json').version")

          # Update app.json expo.version to match
          node -e "
            const fs = require('fs');
            const appJson = JSON.parse(fs.readFileSync('./packages/mobile/app.json', 'utf8'));
            appJson.expo.version = '$MOBILE_VERSION';
            fs.writeFileSync('./packages/mobile/app.json', JSON.stringify(appJson, null, 2) + '\n');
          "

          echo "Synced app.json version to $MOBILE_VERSION"

      - name: Get new version
        id: get_version
        run: |
          if [ "${{ steps.check_changesets.outputs.changeset_count }}" -eq 0 ]; then
            echo "released=false" >> "$GITHUB_OUTPUT"
            echo "version=" >> "$GITHUB_OUTPUT"
          else
            # Get versions from all linked packages and use the highest
            # This handles cases where changesets only bump some packages
            VERSION=$(node -e "
              const semver = require('semver');
              const versions = [
                require('./web-app/package.json').version,
                require('./packages/shared/package.json').version,
                require('./packages/mobile/package.json').version
              ];
              const sorted = versions.sort(semver.rcompare);
              console.log(sorted[0]);
            ")
            echo "version=$VERSION" >> "$GITHUB_OUTPUT"
            echo "released=true" >> "$GITHUB_OUTPUT"
            echo "New version: $VERSION (highest across linked packages)"
          fi

      - name: Extract release notes
        if: steps.get_version.outputs.released == 'true'
        id: release_notes
        run: |
          VERSION="${{ steps.get_version.outputs.version }}"

          # Function to extract notes for a version from a changelog file
          extract_notes() {
            local changelog="$1"
            local ver="$2"
            awk -v ver="$ver" '
              BEGIN { printing=0 }
              /^## / {
                if (printing) { exit }
                # Match: "## 1.3.0" or "## [1.3.0]" (with optional date suffix)
                if (index($0, "## " ver) == 1 || index($0, "## [" ver "]") == 1) {
                  printing=1
                  next
                }
              }
              printing { print }
            ' "$changelog"
          }

          # Collect release notes from all package CHANGELOGs
          # Each package may have different changes for the same version
          > /tmp/release_notes.md

          # Define packages and their changelog paths
          declare -A PACKAGES=(
            ["volleykit-web"]="CHANGELOG.md"
            ["@volleykit/shared"]="packages/shared/CHANGELOG.md"
            ["@volleykit/mobile"]="packages/mobile/CHANGELOG.md"
          )

          FOUND_NOTES=false

          for pkg in "volleykit-web" "@volleykit/shared" "@volleykit/mobile"; do
            changelog="${PACKAGES[$pkg]}"
            if [ -f "$changelog" ]; then
              notes=$(extract_notes "$changelog" "$VERSION")
              if [ -n "$notes" ]; then
                if [ "$FOUND_NOTES" = true ]; then
                  echo "" >> /tmp/release_notes.md
                  echo "---" >> /tmp/release_notes.md
                  echo "" >> /tmp/release_notes.md
                fi
                echo "### $pkg" >> /tmp/release_notes.md
                echo "" >> /tmp/release_notes.md
                echo "$notes" >> /tmp/release_notes.md
                FOUND_NOTES=true
              fi
            fi
          done

          if [ "$FOUND_NOTES" = true ]; then
            echo "Release notes extracted for v$VERSION"
          else
            echo "::warning::No release notes found for v$VERSION in any CHANGELOG"
            echo "No release notes found for v$VERSION" > /tmp/release_notes.md
          fi

      - name: Show changes (dry run)
        if: inputs.dry_run && steps.get_version.outputs.released == 'true'
        run: |
          VERSION="${{ steps.get_version.outputs.version }}"
          TAG="v$VERSION"

          echo "=== Version bump ==="
          echo "New version: $VERSION"
          echo ""
          echo "=== Package versions ==="
          WEB_VERSION=$(node -p "require('./web-app/package.json').version")
          SHARED_VERSION=$(node -p "require('./packages/shared/package.json').version")
          MOBILE_VERSION=$(node -p "require('./packages/mobile/package.json').version")
          echo "  - volleykit-web: $WEB_VERSION"
          echo "  - @volleykit/shared: $SHARED_VERSION"
          echo "  - @volleykit/mobile: $MOBILE_VERSION"
          echo ""

          # Check if tag already exists
          if git tag -l "$TAG" | grep -q "$TAG" || git ls-remote --tags origin "$TAG" | grep -q "$TAG"; then
            echo "::warning::Tag $TAG already exists! Release would fail."
            echo "::warning::Linked packages may have divergent versions."
          fi

          echo "=== CHANGELOG changes ==="
          # Show changelog changes from all packages
          for changelog in CHANGELOG.md packages/shared/CHANGELOG.md packages/mobile/CHANGELOG.md; do
            if [ -n "$(git diff "$changelog" 2>/dev/null)" ]; then
              echo "--- $changelog ---"
              git diff "$changelog"
              echo ""
            fi
          done
          echo ""
          echo "=== package.json changes ==="
          for pkg in web-app/package.json packages/shared/package.json packages/mobile/package.json; do
            if [ -n "$(git diff "$pkg" 2>/dev/null)" ]; then
              echo "--- $pkg ---"
              git diff "$pkg"
              echo ""
            fi
          done
          echo ""
          echo "=== Release notes ==="
          cat /tmp/release_notes.md
          echo ""
          echo "=== Would create tag: $TAG ==="

      - name: Commit changes
        if: ${{ !inputs.dry_run && steps.get_version.outputs.released == 'true' }}
        run: |
          git add .
          git commit -m "$(cat <<'EOF'
          chore(release): prepare v${{ steps.get_version.outputs.version }} release
          EOF
          )"

      - name: Create tag
        if: ${{ !inputs.dry_run && steps.get_version.outputs.released == 'true' }}
        run: |
          VERSION="${{ steps.get_version.outputs.version }}"
          TAG="v$VERSION"

          # Check if tag already exists (locally or remotely)
          if git tag -l "$TAG" | grep -q "$TAG" || git ls-remote --tags origin "$TAG" | grep -q "$TAG"; then
            echo "::error::Tag $TAG already exists!"
            echo "::error::This usually means the linked packages have divergent versions."
            echo "::error::Check that volleykit-web, @volleykit/shared, and @volleykit/mobile have consistent versions."
            echo ""
            echo "Current package versions:"
            WEB_VERSION=$(node -p "require('./web-app/package.json').version")
            SHARED_VERSION=$(node -p "require('./packages/shared/package.json').version")
            MOBILE_VERSION=$(node -p "require('./packages/mobile/package.json').version")
            echo "  - volleykit-web: $WEB_VERSION"
            echo "  - @volleykit/shared: $SHARED_VERSION"
            echo "  - @volleykit/mobile: $MOBILE_VERSION"
            echo ""
            echo "To fix: Ensure all linked packages have the same version, or manually bump versions."
            exit 1
          fi

          git tag -a "$TAG" -m "Release $TAG"

      - name: Push changes
        if: ${{ !inputs.dry_run && steps.get_version.outputs.released == 'true' }}
        run: |
          git push origin ${{ github.event.repository.default_branch }}
          git push origin "v${{ steps.get_version.outputs.version }}"

      - name: Create GitHub Release
        if: ${{ !inputs.dry_run && steps.get_version.outputs.released == 'true' }}
        env:
          GH_TOKEN: ${{ secrets.RELEASE_TOKEN }}
        run: |
          gh release create "v${{ steps.get_version.outputs.version }}" \
            --title "v${{ steps.get_version.outputs.version }}" \
            --notes-file /tmp/release_notes.md

      - name: Summary
        run: |
          VERSION="${{ steps.get_version.outputs.version }}"
          RELEASED="${{ steps.get_version.outputs.released }}"

          if [ "$RELEASED" != "true" ]; then
            echo "## No Release" >> "$GITHUB_STEP_SUMMARY"
            echo "" >> "$GITHUB_STEP_SUMMARY"
            echo "No changesets found. Nothing to release." >> "$GITHUB_STEP_SUMMARY"
          elif [ "${{ inputs.dry_run }}" = "true" ]; then
            echo "## Dry Run Complete" >> "$GITHUB_STEP_SUMMARY"
            echo "" >> "$GITHUB_STEP_SUMMARY"
            echo "| Property | Value |" >> "$GITHUB_STEP_SUMMARY"
            echo "|----------|-------|" >> "$GITHUB_STEP_SUMMARY"
            echo "| New version | v$VERSION |" >> "$GITHUB_STEP_SUMMARY"
            echo "" >> "$GITHUB_STEP_SUMMARY"
            echo "### Release Notes Preview" >> "$GITHUB_STEP_SUMMARY"
            echo "" >> "$GITHUB_STEP_SUMMARY"
            cat /tmp/release_notes.md >> "$GITHUB_STEP_SUMMARY"
          else
            echo "## Release Complete" >> "$GITHUB_STEP_SUMMARY"
            echo "" >> "$GITHUB_STEP_SUMMARY"
            echo "| Property | Value |" >> "$GITHUB_STEP_SUMMARY"
            echo "|----------|-------|" >> "$GITHUB_STEP_SUMMARY"
            echo "| New version | v$VERSION |" >> "$GITHUB_STEP_SUMMARY"
            echo "" >> "$GITHUB_STEP_SUMMARY"
            echo "[View Release](https://github.com/${{ github.repository }}/releases/tag/v$VERSION)" >> "$GITHUB_STEP_SUMMARY"
          fi

  # Build Android APK and attach to release
  build-android:
    needs: release
    if: needs.release.outputs.released == 'true' && !inputs.dry_run && inputs.build_android
    uses: ./.github/workflows/build-mobile-reusable.yml
    with:
      platform: android
      ref: v${{ needs.release.outputs.version }}
      version: ${{ needs.release.outputs.version }}
      upload_to_release: true
      release_tag: v${{ needs.release.outputs.version }}
    secrets:
      EXPO_TOKEN: ${{ secrets.EXPO_TOKEN }}
      RELEASE_TOKEN: ${{ secrets.RELEASE_TOKEN }}

  # Build iOS app and attach to release (optional - requires Apple credentials)
  build-ios:
    needs: release
    if: needs.release.outputs.released == 'true' && !inputs.dry_run && inputs.build_ios
    uses: ./.github/workflows/build-mobile-reusable.yml
    with:
      platform: ios
      ref: v${{ needs.release.outputs.version }}
      version: ${{ needs.release.outputs.version }}
      upload_to_release: true
      release_tag: v${{ needs.release.outputs.version }}
    secrets:
      EXPO_TOKEN: ${{ secrets.EXPO_TOKEN }}
      RELEASE_TOKEN: ${{ secrets.RELEASE_TOKEN }}
      IOS_DIST_CERT_BASE64: ${{ secrets.IOS_DIST_CERT_BASE64 }}
      IOS_DIST_CERT_PASSWORD: ${{ secrets.IOS_DIST_CERT_PASSWORD }}
      IOS_PROVISIONING_PROFILE_BASE64: ${{ secrets.IOS_PROVISIONING_PROFILE_BASE64 }}
