---
/**
 * DeviceScreenshot component
 * Shows screenshots for multiple device types (desktop, phone, tablet) with a device switcher
 */
import { existsSync } from 'node:fs';
import { join } from 'node:path';
import { BASE_PATH, DEVICE_TYPES, DEVICE_SUFFIXES, type DeviceType } from '../constants';

/** Device configuration for display (labels and icons) */
interface DeviceDisplayConfig {
  label: string;
  icon: string;
}

const DEVICE_DISPLAY: Record<DeviceType, DeviceDisplayConfig> = {
  desktop: {
    label: 'Desktop',
    icon: 'M9.75 17L9 20l-1 1h8l-1-1-.75-3M3 13h18M5 17h14a2 2 0 002-2V5a2 2 0 00-2-2H5a2 2 0 00-2 2v10a2 2 0 002 2z',
  },
  phone: {
    label: 'Phone',
    icon: 'M12 18h.01M8 21h8a2 2 0 002-2V5a2 2 0 00-2-2H8a2 2 0 00-2 2v14a2 2 0 002 2z',
  },
  tablet: {
    label: 'Tablet',
    icon: 'M12 18h.01M7 21h10a2 2 0 002-2V5a2 2 0 00-2-2H7a2 2 0 00-2 2v14a2 2 0 002 2z',
  },
};

interface Props {
  /** Unique identifier for the screenshot (used as filename base) */
  id: string;
  /** Alt text describing the screenshot */
  alt: string;
  /** Optional caption displayed below the image */
  caption?: string;
  /** Instructions for capturing the screenshot (for Claude Code) */
  instructions: string;
  /** Which device types to show. Defaults to all devices. */
  devices?: DeviceType[];
}

const { id, alt, caption, instructions, devices = [...DEVICE_TYPES] } = Astro.props;

// Generate a unique ID for this component instance (for tab accessibility)
const componentId = `device-screenshot-${id}`;

// Check which device screenshots exist
const deviceStatus = devices.map((device, index) => {
  const display = DEVICE_DISPLAY[device];
  const suffix = DEVICE_SUFFIXES[device];
  const filename = `${id}${suffix}.png`;
  const imagePath = `${BASE_PATH}/images/screenshots/${filename}`;
  const absolutePath = join(process.cwd(), 'public', 'images', 'screenshots', filename);
  const exists = existsSync(absolutePath);

  return {
    device,
    display,
    suffix,
    filename,
    imagePath,
    exists,
    index,
  };
});

// Find first existing screenshot for default tab
const firstExisting = deviceStatus.find((s) => s.exists);
const defaultDevice = firstExisting?.device ?? devices[0];
---

<figure class="my-8">
  {/* Device Switcher Tabs */}
  <div
    class="mx-auto mb-4 flex max-w-fit rounded-lg border border-border-default bg-surface-subtle p-1 dark:border-border-default-dark dark:bg-surface-subtle-dark"
    role="tablist"
    aria-label="Device type selector"
  >
    {
      deviceStatus.map(({ device, display, index }) => (
        <button
          type="button"
          role="tab"
          id={`${componentId}-tab-${device}`}
          aria-selected={device === defaultDevice ? 'true' : 'false'}
          aria-controls={`${componentId}-panel-${device}`}
          tabindex={device === defaultDevice ? 0 : -1}
          data-device={device}
          data-component-id={componentId}
          data-index={index}
          class:list={[
            'device-tab flex items-center gap-2 rounded-md px-3 py-2 text-sm font-medium transition-colors',
            device === defaultDevice
              ? 'bg-surface-default text-text-primary shadow-sm dark:bg-surface-default-dark dark:text-text-primary-dark'
              : 'text-text-muted hover:text-text-secondary dark:text-text-muted-dark dark:hover:text-text-secondary-dark',
          ]}
        >
          <svg
            class="h-4 w-4"
            fill="none"
            stroke="currentColor"
            viewBox="0 0 24 24"
            aria-hidden="true"
          >
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d={display.icon} />
          </svg>
          <span>{display.label}</span>
        </button>
      ))
    }
  </div>

  {/* Device Panels */}
  {
    deviceStatus.map(({ device, display, filename, imagePath, exists }) => (
      <div
        id={`${componentId}-panel-${device}`}
        role="tabpanel"
        aria-labelledby={`${componentId}-tab-${device}`}
        data-device={device}
        data-component-id={componentId}
        class:list={['device-panel', device !== defaultDevice && 'hidden']}
      >
        {exists ? (
          <img
            src={imagePath}
            alt={`${alt} (${display.label})`}
            class="mx-auto max-w-full rounded-lg border border-border-default shadow-md dark:border-border-default-dark"
            loading="lazy"
          />
        ) : (
          <div class="mx-auto max-w-2xl rounded-lg border-2 border-dashed border-border-strong bg-surface-subtle p-8 text-center dark:border-border-strong-dark dark:bg-surface-subtle-dark">
            {/* Device icon */}
            <svg
              class="mx-auto mb-4 h-12 w-12 text-text-muted dark:text-text-muted-dark"
              fill="none"
              stroke="currentColor"
              viewBox="0 0 24 24"
              aria-hidden="true"
            >
              <path
                stroke-linecap="round"
                stroke-linejoin="round"
                stroke-width="1.5"
                d={display.icon}
              />
            </svg>

            {/* Alt text as label */}
            <p class="mb-2 font-medium text-text-secondary dark:text-text-secondary-dark">
              {alt} ({display.label})
            </p>

            <p class="text-sm text-text-muted dark:text-text-muted-dark">
              Screenshot placeholder - {display.label.toLowerCase()} view
            </p>

            {/*
              Hidden instructions for Claude Code.
              SECURITY NOTE: set:html is safe here because all interpolated values (id, device,
              alt, display.label, filename, instructions) are build-time component props from
              the developer, not runtime user input. The output is also inside an HTML comment.
            */}
            <Fragment
              set:html={`
                <!--
                CLAUDE-CODE-SCREENSHOT-INSTRUCTIONS
                ID: ${id}
                DEVICE: ${device}
                ALT: ${alt} (${display.label})
                PATH: public/images/screenshots/${filename}
                INSTRUCTIONS: ${instructions} Capture this as a ${display.label.toLowerCase()} view${device === 'phone' ? ' (mobile viewport, ~375px width)' : device === 'tablet' ? ' (tablet viewport, ~768px width)' : ' (desktop viewport, ~1280px width)'}.
                -->
              `}
            />
          </div>
        )}
      </div>
    ))
  }

  {/* Caption */}
  {
    caption && (
      <figcaption class="mt-3 text-center text-sm text-text-muted dark:text-text-muted-dark">
        {caption}
      </figcaption>
    )
  }
</figure>

<script>
  // Handle device tab switching with keyboard navigation (WCAG 2.1 compliant)
  function initDeviceSwitcher() {
    const tabs = document.querySelectorAll<HTMLButtonElement>('.device-tab');

    /** Select a tab and update the UI */
    function selectTab(tab: HTMLButtonElement) {
      const device = tab.dataset.device;
      const componentId = tab.dataset.componentId;

      if (!device || !componentId) return;

      // Get all tabs in this component
      const siblingTabs = document.querySelectorAll<HTMLButtonElement>(
        `.device-tab[data-component-id="${componentId}"]`
      );

      // Update all tabs
      siblingTabs.forEach((siblingTab) => {
        const isSelected = siblingTab.dataset.device === device;
        siblingTab.setAttribute('aria-selected', isSelected ? 'true' : 'false');
        // Roving tabindex: only selected tab is in tab order
        siblingTab.setAttribute('tabindex', isSelected ? '0' : '-1');

        // Update visual styles
        if (isSelected) {
          siblingTab.classList.remove(
            'text-text-muted',
            'dark:text-text-muted-dark',
            'hover:text-text-secondary',
            'dark:hover:text-text-secondary-dark'
          );
          siblingTab.classList.add(
            'bg-surface-default',
            'dark:bg-surface-default-dark',
            'text-text-primary',
            'dark:text-text-primary-dark',
            'shadow-sm'
          );
        } else {
          siblingTab.classList.add(
            'text-text-muted',
            'dark:text-text-muted-dark',
            'hover:text-text-secondary',
            'dark:hover:text-text-secondary-dark'
          );
          siblingTab.classList.remove(
            'bg-surface-default',
            'dark:bg-surface-default-dark',
            'text-text-primary',
            'dark:text-text-primary-dark',
            'shadow-sm'
          );
        }
      });

      // Update all panels in this component
      const panels = document.querySelectorAll<HTMLDivElement>(
        `.device-panel[data-component-id="${componentId}"]`
      );
      panels.forEach((panel) => {
        const isVisible = panel.dataset.device === device;
        panel.classList.toggle('hidden', !isVisible);
      });
    }

    tabs.forEach((tab) => {
      // Click handler
      tab.addEventListener('click', () => selectTab(tab));

      // Keyboard navigation (arrow keys for WCAG compliance)
      tab.addEventListener('keydown', (e) => {
        const componentId = tab.dataset.componentId;
        if (!componentId) return;

        const siblingTabs = Array.from(
          document.querySelectorAll<HTMLButtonElement>(
            `.device-tab[data-component-id="${componentId}"]`
          )
        );
        const currentIndex = siblingTabs.indexOf(tab);

        let nextTab: HTMLButtonElement | undefined;

        switch (e.key) {
          case 'ArrowLeft':
            // Move to previous tab (wrap to end)
            nextTab = siblingTabs[(currentIndex - 1 + siblingTabs.length) % siblingTabs.length];
            break;
          case 'ArrowRight':
            // Move to next tab (wrap to start)
            nextTab = siblingTabs[(currentIndex + 1) % siblingTabs.length];
            break;
          case 'Home':
            // Move to first tab
            nextTab = siblingTabs[0];
            break;
          case 'End':
            // Move to last tab
            nextTab = siblingTabs[siblingTabs.length - 1];
            break;
        }

        if (nextTab) {
          e.preventDefault();
          selectTab(nextTab);
          nextTab.focus();
        }
      });
    });
  }

  // Initialize on page load
  initDeviceSwitcher();

  // Re-initialize after Astro page transitions
  document.addEventListener('astro:page-load', initDeviceSwitcher);
</script>
